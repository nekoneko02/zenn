---
title: "SQLの[SELECT .. FOR UPDATE]文で、ダーティリードとデッドロックを防ぐ #RDBMS"
emoji: "👌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["RDB", "RDBMS", "SQL", "ロック", ]
published: false
---
# 概要
RDBにおいて、テーブルから行を読み取り、その値を基に同じ行を更新することを考える。
この時、一般的には以下のような動きになる。

1. 読み取り処理
    2. SQL: SELECT文を発行して、特定の行を読み取る。
    3. ロック: 共有ロックが掛けられる。
4. 更新処理
    5. SQL: UPDATE文を発行して、特定の行を更新する。
    6. ロック: 専有ロックが掛けられる。

※正確にはRDBMSの実装やトランザクション分離レベルに依る

ただ、読み取りの後に更新することが最初からわかっているなら、読み取り処理のときに専有ロックを掛けてもよい気がする（というか掛けた方が良い場合もある）

その時に使うのが、FOR UPDATE句である。
つまり、`SELECT .. FOR UPDATE`のように用いることで、専有ロックを明示的に取得することができる。

本記事では、トランザクションの同時実行により発生するノンリピータブルリードとデッドロックの例を用いて、FOR UPDATE句の動作を考察する。

# 目的
何も考えずに読み取り処理、更新処理を順に行うとデッドロックが発生することがある。

実際、別の記事で考えた例では、共有ロックと専有ロックを段階に取得することでデッドロックが発生した。
できればデッドロックは発生してほしくないので、FOR UPDATE句を使用して防ぐことができないかを考察する。

## 別の記事で考えた例について
> 実際、別の記事で考えた例では、共有ロックと専有ロックを段階に取得することでデッドロックが発生した。

以下の記事に記載した例のことです。
※「(2)REPEATABLE READと2相ロック」節で、ノンリピータブルリードを防ぐためにトランザクション分離レベルREPEATABLE READを使用するとデッドロックが発生することになった。
https://zenn.dev/neko_student/articles/66cc065cf9f848

※基本的に、本記事を読むだけで完結するように書きましたが、興味のある方は上の記事も参照ください。

## 対象読者
共有ロックと専有ロック・2相ロック等の基本的な知識は前提とします。
分かりやすい記事がたくさんあるので、そちらを参照ください。

# FOR UPDATE句を考察する
まずは、ノンリピータブルリード・デッドロックが発生する例を見る。
※先ほど紹介した[RDBにおける、共有ロック/占有ロック・2相ロック・トランザクション分離レベルの関係をシーケンスで説明する](https://zenn.dev/neko_student/articles/66cc065cf9f848)と同じ例です。

その後に、FOR UPDATEを使うことで、どのように改善ができるかを考察する。
## ノンリピータブルリードが発生する例
トランザクション分離レベルはREAD COMMITEDとする。つまり、ロックは以下のように取得する：
- 共有ロックをかける（読み取りが終わったら、すぐ解放してよい）
- 2相ロックに従って、専有ロックをかける。

以下のトランザクションではノンリピータブルリードが発生してしまう。

- Aさんの口座残高の初期値が500円
- Aさんは300円を引き出したい
- クレジットカード会社は300円を引き落としたい

![no-repeatable-read](/images/no-repeatable-read.png)

## デッドロックが発生する例
ノンリピータブルリードを防ぐために、トランザクション分離レベルをREPEATABLE READにしてみる。つまり、ロックは以下のように取得する：
- 2相ロックに従って、共有ロックと専有ロックをかける。

この時、同じ例を考えるとデッドロックが発生してしまう。

- Aさんの口座残高の初期値が500円
- Aさんは300円を引き出したい
- クレジットカード会社は300円を引き落としたい


![no-repeatable-read-lock](/images/no-repeatable-read-lock.png)

お互いが、お互いの共有ロック待ち状態になってしまった。

## FOR UPDATE句を使う
2つの例で発生したノンリピータブルリードとデッドロックをどうすれば防げるかを考察する。

結論、読み取りの後に更新することがわかっているので、最初から専有ロックを掛けてしまえばよい。

同じ例において、読み取り処理時に専有ロックを取得する(FOR UPDATE指定する)ことを考える。
- Aさんの口座残高の初期値が500円
- Aさんは300円を引き出したい
- クレジットカード会社は300円を引き落としたい

![no-repeatable-read-for-update](/images/no-repeatable-read-for-update.png)

クレジットカードの支払いができませんでしたが、整合性は取れました。

### 補足
今回の例では、FOR UPDATE句を使うことで専有ロックしか掛けていない。
なので、トランザクション分離レベルはREAD COMMITEDとREPEATABLE READのどちらでもよいことになる。

# まとめ
今回の例では、FOR UPDATE句を使うことでノンリピータブルリードやデッドロックが防ぐことができた。

専有ロックは強めのロックなので多用はできないが、今回のような場合では有効であると考えられる。

# 参考文献
- [データベーススペシャリスト試験 令和6年度 午後2 問1](https://www.ipa.go.jp/shiken/mondai-kaiotu/m42obm000000afqx-att/2024r06a_db_pm2_qs.pdf)
  - 超直近だが、FOR UPDATEに関する記載や問題がある
- [RDBにおける、共有ロック/占有ロック・2相ロック・トランザクション分離レベルの関係をシーケンスで説明する](https://zenn.dev/neko_student/articles/66cc065cf9f848)